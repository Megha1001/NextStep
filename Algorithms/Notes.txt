1. Euclidean algorithm -> To find GCD
    Let 'b' be smaller than 'a'
    gcd(a, b) = gcd(a-b, b)

    why ?
    Let 'g' be GCD of 'a' and 'b'
    a = gx, b = gy and gcd(x, y) = 1

    (a-b) = g(x-y)

2. Optimized Version of Euclidean algorithm
    gcd(int a, int b){
        if(b==0){
            return a;
        }
        return gcd(b, a%b)
    }

3. LCM of two numbers
    a*b = gcd(a,b) * lcm(a,b)


4. Pow(x,n)
    if(n%2==0) => pow(x,n/2) * pow(x,n/2)
    else => x * pow(x,n/2) * pow(x,n/2)

5. 2's complement representation of -x = 2^32 - x


6. Brain and kerningham Algorithm
 - Identify the rightmost set bit using n & (n-1). This operation clears the least significant set bit of n.
 - Repeat the process until the number becomes 0
 - Count the number of iterations

7. Use of Brain and kerningham for lookup table solution to count the bits

package bitsMagic.countSetBits;
/*
 * Assumption : We have 32 bits numbers
 * 
 * => Precompute count for 8 bit number(0 to 255)
 *  tbl[0] = 0
 * for(int i=1; i<256;i++)
 *  tbl[i] = tbl[i&(i-1)] + 1
 * 
 * => Now to count set bits in given number ( & 255 then shift by 8)
 * 
 * Time Complexity : O(1)
 */

public class LookupTableSolution {

    private static int[]tbl = new int[256];

    public static void main(String args[]){
        
        precomputeCountBitsOfNum();
        int n = 5;
        System.out.println("Count of Set bits in given number is : "+countOfSetBits(n));
    }

    public static void precomputeCountBitsOfNum(){

        tbl[0] = 0;

        for(int i =1; i<256; i++){
            tbl[i] = tbl[i & (i-1)] + 1;
        }

    }

    public static int countOfSetBits(int n){
        return tbl[n&255]
        + tbl[(n>>8)&255]
        + tbl[(n>>16)&255]
        tbl[n>>24];
    }

    
}
