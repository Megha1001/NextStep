1. Euclidean algorithm -> To find GCD
    Let 'b' be smaller than 'a'
    gcd(a, b) = gcd(a-b, b)

    why ?
    Let 'g' be GCD of 'a' and 'b'
    a = gx, b = gy and gcd(x, y) = 1

    (a-b) = g(x-y)

2. Optimized Version of Euclidean algorithm
    gcd(int a, int b){
        if(b==0){
            return a;
        }
        return gcd(b, a%b)
    }

3. LCM of two numbers
    a*b = gcd(a,b) * lcm(a,b)


4. Pow(x,n)
    if(n%2==0) => pow(x,n/2) * pow(x,n/2)
    else => x * pow(x,n/2) * pow(x,n/2)

5. 2's complement representation of -x = 2^32 - x


6. Brain and kerningham Algorithm
 - Identify the rightmost set bit using n & (n-1). This operation clears the least significant set bit of n.
 - Repeat the process until the number becomes 0
 - Count the number of iterations

7. Use of Brain and kerningham for lookup table solution to count the bits

package bitsMagic.countSetBits;
/*
 * Assumption : We have 32 bits numbers
 * 
 * => Precompute count for 8 bit number(0 to 255)
 *  tbl[0] = 0
 * for(int i=1; i<256;i++)
 *  tbl[i] = tbl[i&(i-1)] + 1
 * 
 * => Now to count set bits in given number ( & 255 then shift by 8)
 * 
 * Time Complexity : O(1)
 */

public class LookupTableSolution {

    private static int[]tbl = new int[256];

    public static void main(String args[]){
        
        precomputeCountBitsOfNum();
        int n = 5;
        System.out.println("Count of Set bits in given number is : "+countOfSetBits(n));
    }

    public static void precomputeCountBitsOfNum(){

        tbl[0] = 0;

        for(int i =1; i<256; i++){
            tbl[i] = tbl[i & (i-1)] + 1;
        }

    }

    public static int countOfSetBits(int n){
        return tbl[n&255]
        + tbl[(n>>8)&255]
        + tbl[(n>>16)&255]
        tbl[n>>24];
    } 
}


8. To find the number which has only 1 bit set and the set bit corresponds to last set bit of x
    x & (~(x-1))


9. Tower of Hanoi
    TOH(n, A, B, C)
        -> TOH(n-1, A, C, B)
        -> Move n from A to C
        -> TOH(n-1, B, A, C)

10. Reverse Algorithm [used to rotate array by d position]
    reverse(arr, 0, d-1)
    reverse(arr, d, n-1)
    reverse(arr, 0, n-1)

11. Stock buy and sell


    public static void main(String args[]){
        int arr[] = {1,5,3,8,12}; //13
        System.out.println("Max profit that can be earned is : "+findProfit(arr, arr.length));
    }

    public static int findProfit(int arr[], int n){
       int profit = 0;
       for(int i = 1; i<n; i++){
            if(arr[i] > arr[i-1]){
                profit += arr[i] - arr[i-1];
            }
       }

       return profit;
    }
    

12. Kadane’s Algorithm finds the maximum subarray sum in an array of integers.
    At each number x, you decide:
        Should I start a new subarray at x
        or extend the current subarray?

public static int findMaxSumSubArray(int arr[], int n){

        int res = arr[0];
        int max_ending = arr[0];

        for(int i=0; i<n; i++){
            max_ending = Math.max(max_ending + arr[i], arr[i]);
            res = Math.max(res, max_ending);
        }

        return res;

    }

Note : Can also be used to find out max even odd subarray length


13. Kadane's Algo - To find maximum sum of subarray in circular array
    -> find maximum sum of subarray in normal array
    -> Total sum - find min sum of subarray in normal array
    -> res = Math.max(step1, step 2)

    CORNER CASE : 
       if(maxSumOfNormalArray < 0){
            return maxSumOfNormalArray;
        }


14. Josephus Problem

    public static int findSurvivedPersonIdx(int n, int k){

        if(n==1){
            return 0;
        }

        return (k+findSurvivedPersonIdx(n-1, k)) %n;

    }


15. Moore's voting algorithm -> To find Majority Element
    This is a two step process
        - The first step gives the element that may bbe the mojority element in the array. If there is a majority element in an array,
        then this step will definitely return majority element, otherwise it will return candidate for majority element
        - Check if the element obtained from the above step is the majority element. This step is necessary as there might be no majority element.
        

16. Minimum number of flips
package Arrays.minimumConsecutiveFlips;

/*
 *  DIFFERENCE CAN BE ATMOST ONCE
 *  
 * There can be two possibilites
 *  1. Difference is 1
 *      -> The first and last element is same
 *  
 *  2. Difference is 0
 *      -> First and fast element is different
 * 
 *  ALWAYS PRINT THE SECOND GROUP
 */

public class EfficientSolution {

    public static void main(String args[]){
        int arr[] = {0,0,1,1,0,0,1,1,0,1};
        System.out.println("Flips are :- ");
        findAndPrintFlips(arr, arr.length);
    }

    public static void findAndPrintFlips(int arr[], int n){

        for(int i=1; i<n; i++){
            if(arr[i] != arr[i-1]){
                //start
                if(arr[i] != arr[0]){
                    System.out.print("From "+i+" to ");
                }else { //end
                    System.out.println(i-1);
                }
            }
        }
        //to print last 1  {0,0,1,1,0,0,1,1,0,1}
        if(arr[n-1] != arr[0]){
            System.out.println(n-1);
        }
        
    }
    
}

17. Search in infinite sorted array
package searching.searchInInfiniteSizedArray;

/*
 * TIME COMPLEXITY : O(logN)
 * AUXILIARY SPACE : O(1)
 */

public class EfficientSolutionUsingBS {
    
    public static void main(String args[]){

        int arr[] = {1, 2, 3, 40, 50}; // assume it to be infinite array
        int x = 40;

        System.out.println("The required element is present at idx : "+searchElement(arr, x));
    }

    public static int searchElement(int arr[], int x){
       
        //check for 0th index solely
        if(arr[0] == x){
            return 0;
        }

        int i=1;
        while(arr[i] < x){ //find upper bound
            i = i*2;
        }

        //either = or > x
        if(arr[i] == x){
            return i;
        }

        return binarySearch(arr, (i/2)+1, i-1, x);
    }

    public static int binarySearch(int arr[], int start, int end, int x){

        while(start <= end){
            int mid = start + (end-start)/2;

            if(arr[mid]==x){
                return mid;
            }

            else if (arr[mid] > x){
                end = mid-1;
            }else {
                start = mid+1;
            }
        }

        return -1;
    }
    
}

18. Peak Element
 * IDEA : If arr[m] <= arr[m-1] --> there will always be a peak element at left side
 *      or  
 * arr[m] <=arr[m+1] -> there will always be a peak element on right side

NOTE : The other half that we discard doesn't mean there would not be any peak . the half where we go that definately gurantee to contain a PEAK



19. Naive partition
public static void partition(int arr[], int l, int h, int p){

        int temp [] = new int[h-l+1];
        int idx = 0; //for temp array

        //copy element <=arr[p]
        for(int i=l; i<=h; i++){
            if(arr[i] <= arr[p] && i!=p){
                temp[idx++] = arr[i];
            }
        }

        //copy partition element
        temp[idx++] = arr[p];

        //copy element > arr[p]
        for(int i=l; i<=h; i++){
            if(arr[i] > arr[p]){
                temp[idx++] = arr[i];
            }
        }


        //copy and print to original array
        for(int i=l ;i<=h; i++){
            arr[i] = temp[i-l];
            System.out.print(arr[i]+" ");
        }


    }


20 . Lomuto Partition -> Pivot is always last

public static int partition(int arr[], int l, int h){
        int p = h
        int i = l-1;
        int pivotValue = arr[h]; 

        for(int j=l; j<=h; j++){
            if(arr[j] < pivotValue){
                ++i;
                //swap
                int temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
            }
        }

        //swap arr[i+1] and arr[p]
        int temp = arr[i+1];
        arr[i+1] = arr[p];
        arr[p] = temp;
        return (i+1);

    } 

21; Hoare's partition
    public static int partition(int arr[], int l, int h){
        int i= l-1;
        int j= h+1;
        int pivot = arr[l];

        while(true){
            do{
                ++i;
            }while(arr[i] < pivot);

            do{
                --j;
            }while(arr[j] > pivot);

            if(i>=j){
                return j;//pivot index
            }

            //swap 
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }

    }


22. Quick Select algorithm - To find kth smallest / kth largest

  public static int findKthSmallest(int arr[], int n, int k){
        int l=0; 
        int h= n-1;

        while(l<=h){ //why = its not sorting its searching hence we need to check element at = position as well
            int p = partition(arr, l, h); // LOMUTO PARTITION
            
            if(p==k-1){
                return arr[p];
            }

            else if (p>k-1){
                h = p-1;
            }
            else {
                l = p+1;
            }

        }

        return -1;
    }

23. Dutch National Flag algorithm

public static void sortUsingDutchNationalFlagAlgo(int arr[], int n){
        int l = 0;
        int m = 0;
        int h = n-1;

        while(m<=h){
            if(arr[m]==0){
                int temp = arr[l];
                arr[l] = arr[m];
                arr[m] = temp;
                ++m; //we increment since when we replaced arr[m] with arr[l], we know that arr[l] should be 1
                ++l;
            }

            else if(arr[m]==1){
                ++m;
            }

            else { //for 2
                int temp = arr[h];
                arr[h] = arr[m];
                arr[m] = temp;
                
                --h; //we are only --h since when we replaced arr[m] with arr[h], we dont know what is there on arr[h]
            }
        }

        //print
        for(int i=0; i<n; i++){
            System.out.print(arr[i]+" ");
        }

    }

24 Jagged Array : A 2D array is called jagged array is all the rows are not of same size

25. Java passes object references by value.
You can change the object, but you cannot change what the caller’s reference points to.

26. Reverse DLL
    public static Node reverseDLL(Node head){
        if(head == null || head.next==null){
            return head;
        }

        Node curr = head;
        Node prev = null;

        while(curr != null){
            prev = curr.prev;
            curr.prev = curr.next;
            curr.next = prev;

            //curr.next now becomes curr.prev
            curr = curr.prev;
        }

        return prev.prev;


    }

27. Find Middle in SLL
/*
 * IDEA : Use slow and fast references
 * 1. Move slow by 1 and fast by two reference until fast reaches end
 *  Odd : fast != null
 *  Even : fast.next != null
 * 
 * When fast reached end, slow will be in middle
 * 
 * TIME COMPLEXITY : O(N) --> But one traversal
 * AUXILIARY SPACE : O(1);
 */

    public static Node findMiddleElement(Node head){

        if(head == null){
            return null;
        }


        Node slow = head;
        Node fast = head;

        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
        

    }

    NOTE : TO get the first middle (Question : Find middle of LL)
    while(fast.next !=null && fast.next.next !=null) --> this is the condition instead of while(fast !=null && fast.next != null)


28.  Floyd's detection algo
    public static boolean isLoopFound(Node head){

        Node slow = head;
        Node fast = head;

        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;

            if(slow==fast){
                return true;
            }
        }

        return false;

    }

29. Stack : Always use ArrayDequeue implementation 
                    Collection
                        |
           --------------------------------
           |                              |
          List                          Queue
           |                              |
        Vector                           Deque
           |                  (Double Ended Queue)
          Stack                            |
                                      ArrayDeque
Stack implements Vector (that is legacy class and is thread safe. Since, its thread safe it comes with cost of performance)

Both - Stack and ArrayDeque are dynamic array implementation(Amotized O(1))


30. Operator Precedence & Associativity

| Operator(s) | Operation                | Associativity | Precedence |
| ----------- | ------------------------ | ------------- | ---------- |
| `^`         | Exponentiation           | Right → Left  | Highest    |
| `* , /`     | Multiplication, Division | Left → Right  | Medium     |
| `+ , -`     | Addition, Subtraction    | Left → Right  | Lowest     |



31.Queue / Deque Method Comparison
| **Operation Type** | **Throws Exception** | **Returns Special Value** | **Behavior on Failure**                                                       |
| ------------------ | -------------------- | ------------------------- | ----------------------------------------------------------------------------- |
| **Insert**         | `add(e)`             | `offer(e)`                | `add()` throws `IllegalStateException` if full; `offer()` returns `false`     |
| **Remove**         | `remove()`           | `poll()`                  | `remove()` throws `NoSuchElementException` if empty; `poll()` returns `null`  |
| **Examine**        | `element()`          | `peek()`                  | `element()` throws `NoSuchElementException` if empty; `peek()` returns `null` |

31. Can we build a binary tree from INORDER alone?
NO — it is NOT possible (in general).


32. isBalanced
public static int isBalanced(Node root){
        if(root == null){
            return 0; //height
        }

        int lh = isBalanced(root.left);
        if(lh==-1){
            return -1;
        }

        int rh = isBalanced(root.right);
        if(rh==-1){
            return -1;
        }

        if(Math.abs(lh-rh)>1){
            return -1;
        }else{
            return Math.max(lh,rh) + 1;
        }
    }

33. Binary Tree to Double LL
public static Node BTToDLL(Node root){
        if(root == null){
            return root;
        }

        //left
        Node head = BTToDLL(root.left);

        //node
        if(prev == null){
            head = root;
        }
        else{
            root.left = prev;
            prev.right = root;
        }
        prev = root;

        //right
        BTToDLL(root.right);

        return head;

    }

34. AVL Tree - Every node should have balance factor <=1 
balance factor = |lh - rh| <=1 
i.e. Mode of left_height - right_height <=1

-> search fast and strict
-> Insertion : we need to rotate/correct only unbalanced node not all the ancestor but in deletion we need to check all ancestors

35. Red black tree 
Every node is either Red or black
Root is always black
No two consecutive reds
Number of black nodes from every node to all of its descandant leaf should be same
Number of nodes on the path from a node to its farthest descendant leaf should not be more than twice than the number of nodes on the path of closest descendant leaf

36.The Golden Rule of return in recursion

Ask one question:
Does the result of the recursive call matter to the current function?
If YES → you MUST return it
If NO → you just call it (no return)
That’s it. Everything else comes from this.


Vertical order traversal must use BFS, not DFS

37. Kahn's Algorithm -> Topological sorting

Topological sorting is only for acyclic graphs

STEPS
------
1. Find indegree of all the vertices
2. Create a queue;
3. Add all the vertices with indgree 0 in the queue
4. Until q is not empty
    -> u = q.poll();
    -> S.O.P(u)
    -> for every adjancent v of u
        -> --indegree[v];
        -> if(indegree[v]==0) add in queue

------
public static void topologicalSorting(ArrayList<ArrayList<Integer>>adj, int v){
        int [] indegree = new int[v];
        calculateIndgree(adj, indegree);
        
        //put all vertex with indegree 0 in queue
        ArrayDeque<Integer> q = new ArrayDeque<>();

        for(int i=0; i<v; i++){
            if(indegree[i]==0){
                q.offer(i);
            }
        }

        while(!q.isEmpty()){
            int p = q.poll();
            System.out.print(p + " ");

            for(int u : adj.get(p)){
                --indegree[u];
                if(indegree[u] == 0){
                    q.offer(u);
                }
            }
        }
    }

    public static void calculateIndgree(ArrayList<ArrayList<Integer>>adj, int [] indegree){
        //calculate indegree
        for(int i=0; i<adj.size(); i++){
            for(int j=0; j<adj.get(i).size(); j++){
                ++indegree[adj.get(i).get(j)];
            }
        }

        // for(int i: indegree){
        //     System.out.print(i + " ");
        // }
    }

38. Shortest Path in DAG : O(V+E)
-> Intitialize dist[V] = {INF, INF, INF,.....}
-> dist[s] = 0;
-> Find a topological sort of the graph with s=0
-> for every vertex u in the topological sort
    -> for every adjacent v of u
        if dist[v] > dist[u] + weight(u, v)
        dist[v] = dist[u] + weight(u,v)