1. Euclidean algorithm -> To find GCD
    Let 'b' be smaller than 'a'
    gcd(a, b) = gcd(a-b, b)

    why ?
    Let 'g' be GCD of 'a' and 'b'
    a = gx, b = gy and gcd(x, y) = 1

    (a-b) = g(x-y)

2. Optimized Version of Euclidean algorithm
    gcd(int a, int b){
        if(b==0){
            return a;
        }
        return gcd(b, a%b)
    }

3. LCM of two numbers
    a*b = gcd(a,b) * lcm(a,b)


4. Pow(x,n)
    if(n%2==0) => pow(x,n/2) * pow(x,n/2)
    else => x * pow(x,n/2) * pow(x,n/2)

5. 2's complement representation of -x = 2^32 - x


6. Brain and kerningham Algorithm
 - Identify the rightmost set bit using n & (n-1). This operation clears the least significant set bit of n.
 - Repeat the process until the number becomes 0
 - Count the number of iterations

7. Use of Brain and kerningham for lookup table solution to count the bits

package bitsMagic.countSetBits;
/*
 * Assumption : We have 32 bits numbers
 * 
 * => Precompute count for 8 bit number(0 to 255)
 *  tbl[0] = 0
 * for(int i=1; i<256;i++)
 *  tbl[i] = tbl[i&(i-1)] + 1
 * 
 * => Now to count set bits in given number ( & 255 then shift by 8)
 * 
 * Time Complexity : O(1)
 */

public class LookupTableSolution {

    private static int[]tbl = new int[256];

    public static void main(String args[]){
        
        precomputeCountBitsOfNum();
        int n = 5;
        System.out.println("Count of Set bits in given number is : "+countOfSetBits(n));
    }

    public static void precomputeCountBitsOfNum(){

        tbl[0] = 0;

        for(int i =1; i<256; i++){
            tbl[i] = tbl[i & (i-1)] + 1;
        }

    }

    public static int countOfSetBits(int n){
        return tbl[n&255]
        + tbl[(n>>8)&255]
        + tbl[(n>>16)&255]
        tbl[n>>24];
    } 
}


8. To find the number which has only 1 bit set and the set bit corresponds to last set bit of x
    x & (~(x-1))


9. Tower of Hanoi
    TOH(n, A, B, C)
        -> TOH(n-1, A, C, B)
        -> Move n from A to C
        -> TOH(n-1, B, A, C)

10. Reverse Algorithm [used to rotate array by d position]
    reverse(arr, 0, d-1)
    reverse(arr, d, n-1)
    reverse(arr, 0, n-1)

11. Stock buy and sell


    public static void main(String args[]){
        int arr[] = {1,5,3,8,12}; //13
        System.out.println("Max profit that can be earned is : "+findProfit(arr, arr.length));
    }

    public static int findProfit(int arr[], int n){
       int profit = 0;
       for(int i = 1; i<n; i++){
            if(arr[i] > arr[i-1]){
                profit += arr[i] - arr[i-1];
            }
       }

       return profit;
    }
    

12. Kadaneâ€™s Algorithm finds the maximum subarray sum in an array of integers.
    At each number x, you decide:
        Should I start a new subarray at x
        or extend the current subarray?

    for(int i=1; i<n; i++){
        max_ending = Math.max(max_ending + arr[i-1], arr[i])
        res = Math.max(res, max_ending);
    }

Note : Can also be used to find out max even odd subarray length


13. Kadane's Algo - To find maximum sum of subarray in circular array
    -> find maximum sum of subarray in normal array
    -> Total sum - find min sum of subarray in normal array
    -> res = Math.max(step1, step 2)

    CORNER CASE : 
       if(maxSumOfNormalArray < 0){
            return maxSumOfNormalArray;
        }


14. Josephus Problem

    public static int findSurvivedPersonIdx(int n, int k){

        if(n==1){
            return 0;
        }

        return (k+findSurvivedPersonIdx(n-1, k)) %n;

    }


15. Moore's voting algorithm -> To find Majority Element
    This is a two step process
        - The first step gives the element that may bbe the mojority element in the array. If there is a majority element in an array,
        then this step will definitely return majority element, otherwise it will return candidate for majority element
        - Check if the element obtained from the above step is the majority element. This step is necessary as there might be no majority element.
        

16. Minimum number of flips
package Arrays.minimumConsecutiveFlips;

/*
 *  DIFFERENCE CAN BE ATMOST ONCE
 *  
 * There can be two possibilites
 *  1. Difference is 1
 *      -> The first and last element is same
 *  
 *  2. Difference is 0
 *      -> First and fast element is different
 * 
 *  ALWAYS PRINT THE SECOND GROUP
 */

public class EfficientSolution {

    public static void main(String args[]){
        int arr[] = {0,0,1,1,0,0,1,1,0,1};
        System.out.println("Flips are :- ");
        findAndPrintFlips(arr, arr.length);
    }

    public static void findAndPrintFlips(int arr[], int n){

        for(int i=1; i<n; i++){
            if(arr[i] != arr[i-1]){
                //start
                if(arr[i] != arr[0]){
                    System.out.print("From "+i+" to ");
                }else { //end
                    System.out.println(i-1);
                }
            }
        }
        //to print last 1  {0,0,1,1,0,0,1,1,0,1}
        if(arr[n-1] != arr[0]){
            System.out.println(n-1);
        }
        
    }
    
}

17. Search in infinite sorted array
package sorting.searchInInfiniteSizedArray;

/*
 * TIME COMPLEXITY : O(logN)
 * AUXILIARY SPACE : O(1)
 */

public class EfficientSolutionUsingBS {
    
    public static void main(String args[]){

        int arr[] = {1, 2, 3, 40, 50}; // assume it to be infinite array
        int x = 40;

        System.out.println("The required element is present at idx : "+searchElement(arr, x));
    }

    public static int searchElement(int arr[], int x){
       
        //check for 0th index solely
        if(arr[0] == x){
            return 0;
        }

        int i=1;
        while(arr[i] < x){ //find upper bound
            i = i*2;
        }

        //either = or > x
        if(arr[i] == x){
            return i;
        }

        return binarySearch(arr, (i/2)+1, i-1, x);
    }

    public static int binarySearch(int arr[], int start, int end, int x){

        while(start <= end){
            int mid = start + (end-start)/2;

            if(arr[mid]==x){
                return mid;
            }

            else if (arr[mid] > x){
                end = mid-1;
            }else {
                start = mid+1;
            }
        }

        return -1;
    }
    
}

18. Peak Element
 * IDEA : If arr[m] <= arr[m-1] --> there will always be a peak element at left side
 *      or  
 * arr[m] <=arr[m+1] -> there will always be a peak element on right side

NOTE : The other half that we discard doesn't mean there would not be any peak . the half where we go that definately gurantee to contain a PEAK