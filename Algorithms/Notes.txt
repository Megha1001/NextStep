1. Euclidean algorithm -> To find GCD
    Let 'b' be smaller than 'a'
    gcd(a, b) = gcd(a-b, b)

    why ?
    Let 'g' be GCD of 'a' and 'b'
    a = gx, b = gy and gcd(x, y) = 1

    (a-b) = g(x-y)

2. Optimized Version of Euclidean algorithm
    gcd(int a, int b){
        if(b==0){
            return a;
        }
        return gcd(b, a%b)
    }

3. LCM of two numbers
    a*b = gcd(a,b) * lcm(a,b)


4. Pow(x,n)
    if(n%2==0) => pow(x,n/2) * pow(x,n/2)
    else => x * pow(x,n/2) * pow(x,n/2)

5. 2's complement representation of -x = 2^32 - x


6. Brain and kerningham Algorithm
 - Identify the rightmost set bit using n & (n-1). This operation clears the least significant set bit of n.
 - Repeat the process until the number becomes 0
 - Count the number of iterations

7. Use of Brain and kerningham for lookup table solution to count the bits

package bitsMagic.countSetBits;
/*
 * Assumption : We have 32 bits numbers
 * 
 * => Precompute count for 8 bit number(0 to 255)
 *  tbl[0] = 0
 * for(int i=1; i<256;i++)
 *  tbl[i] = tbl[i&(i-1)] + 1
 * 
 * => Now to count set bits in given number ( & 255 then shift by 8)
 * 
 * Time Complexity : O(1)
 */

public class LookupTableSolution {

    private static int[]tbl = new int[256];

    public static void main(String args[]){
        
        precomputeCountBitsOfNum();
        int n = 5;
        System.out.println("Count of Set bits in given number is : "+countOfSetBits(n));
    }

    public static void precomputeCountBitsOfNum(){

        tbl[0] = 0;

        for(int i =1; i<256; i++){
            tbl[i] = tbl[i & (i-1)] + 1;
        }

    }

    public static int countOfSetBits(int n){
        return tbl[n&255]
        + tbl[(n>>8)&255]
        + tbl[(n>>16)&255]
        tbl[n>>24];
    } 
}


8. To find the number which has only 1 bit set and the set bit corresponds to last set bit of x
    x & (~(x-1))


9. Tower of Hanoi
    TOH(n, A, B, C)
        -> TOH(n-1, A, C, B)
        -> Move n from A to C
        -> TOH(n-1, B, A, C)

10. Reverse Algorithm [used to rotate array by d position]
    reverse(arr, 0, d-1)
    reverse(arr, d, n-1)
    reverse(arr, 0, n-1)

11. Stock buy and sell


    public static void main(String args[]){
        int arr[] = {1,5,3,8,12}; //13
        System.out.println("Max profit that can be earned is : "+findProfit(arr, arr.length));
    }

    public static int findProfit(int arr[], int n){
       int profit = 0;
       for(int i = 1; i<n; i++){
            if(arr[i] > arr[i-1]){
                profit += arr[i] - arr[i-1];
            }
       }

       return profit;
    }
    

12. Kadaneâ€™s Algorithm finds the maximum subarray sum in an array of integers.
    At each number x, you decide:
        Should I start a new subarray at x
        or extend the current subarray?

    for(int i=1; i<n; i++){
        max_ending = Math.max(max_ending + arr[i-1], arr[i])
        res = Math.max(res, max_ending);
    }

Note : Can also be used to find out max even odd subarray length


13. Kadane's Algo - To find maximum sum of subarray in circular array
    -> find maximum sum of subarray in normal array
    -> Total sum - find min sum of subarray in normal array
    -> res = Math.max(step1, step 2)

    CORNER CASE : 
       if(maxSumOfNormalArray < 0){
            return maxSumOfNormalArray;
        }